6.4  Node.js 不是银弹 
在本书正文的最后一节，我们打算讨论一下Node.js 不适合做什么，涉及它的不足之处
和一些弊端。 
在西方古老的传说里，有一种叫做“狼人”的可怕生物。这种生物平时和人类没有什么
不同之处，但每到月圆之夜，他们就会变成狼身。当他们变成狼以后，兽性会不能控制，开
始袭击普通的人类。狼人给人类带来了巨大的恐惧，因为他们是无法被一般的手段杀死的，
只有用赐福过的银弹（Silver Bullet）才能杀死狼人。“银弹”因此成为了“任何能够带来极
大效果的直接解决方案”的代名词。 
Fred Brooks
①
在1987 年发表了一篇关于软件工程的经典文章——“No Silver Bullet”（没
有银弹）。所谓的“没有银弹”指的就是没有任何一项技术或方法可使软件工程的生产力能
像摩尔定律一样在十年内提高超过十倍，不仅当时没有，现在也没有，今后也不会有。这篇
文章收录在《人月神话》（The Mythical Man-Month）一书中，被誉为软件工程领域的基本定
律之一。 
Node.js 也不例外，它不是什么能够大幅度提高软件开发效率和质量的灵丹妙药。无论
使用什么语言、工具，所能改变的仅仅是开发的舒适程度和方便程度，而最终软件的好坏所
能改变的范围相当有限。任何试图以限制程序员犯错来提高软件质量的方式最终都已经以失
败告终。真正优秀的软件是靠优秀的程序员开发出来的，优秀的语言、平台、工具只有在优
秀的程序员的手中才能显现出它的威力。 
Node.js 不适合做什么 
Node.js 是一个优秀的平台，吸引大量开发者关注。它有许多传统架构不具备的优点，
以至于我们情不自禁地愿意用它来做开发。Node.js  和任何东西一样，都有它擅长的和不擅
长的事情，如果你非要用它来做它不擅长的事情，那么你将会陷入僵局之中。尽管你可以以
喜欢、它很新潮、性能高为借口，却不得不写出难看的代码。 
和大多数新技术的本质一样，Node.js  也只是旧瓶盛新酒。大多数人事实上并不知道为
什么使用Node.js，只是因为你了解它，所以使用它，进而觉得它好，觉得它是最合适的。这
是一个必须跳出的误区，否则你就像是得了强迫症，不管三七二十一，遇到什么问题都用
—————————— 
① IBM  大型计算机之父，曾经开发过OS/360 等大型计算机的操作系统。 
6.4  Node.js 不是银弹   145 
 
1 
2 
3 
5 
7 
10 
8 
9 
4 
6 
Node.js 解决。 
所以现在就让我们来谈谈 Node.js  不适合做的事情吧。 
1. 计算密集型的程序 
在Node.js 0.8  版本之前，Node.js 不支持多线程。当然，这是一种设计哲学问题，因为
Node.js的开发者和支持者坚信单线程和事件驱动的异步式编程比传统的多线程编程运行效
率更高。但事实上多线程可以达到同样的吞吐量，尽管可能开销不小，但不必为多核环境进
行特殊的配置。相比之下，Node.js 由于其单线程性的特性，必须通过多进程的方法才能充
分利用多核资源。 
理想情况下，Node.js单线程在执行的过程中会将一个CPU 核心完全占满，所有的请求必
须等待当前请求处理完毕以后进入事件循环才能响应。如果一个应用是计算密集型的，那么
除非你手动将它拆散，否则请求响应延迟将会相当大。例如，某个事件的回调函数中要进行
复杂的计算，占用CPU 200 毫秒，那么事件循环中所有的请求都要等待200 毫秒。为了提高
响应速度，你唯一的办法就是把这个计算密集的部分拆成若干个逻辑，这给编程带来了额外
的复杂性。即使这样，系统的总吞吐量和总响应延迟也不会降低，只是调度稍微公平了一些。 
不过好在真正的Web  服务器中，很少会有计算密集的部分，如果真的有，那么它不应该
被实现为即时的响应。正确的方式是给用户一个提示，说服务器正在处理中，完成后会通知
用户，然后交给服务器的其他进程甚至其他专职的服务器来做这件事。 
2. 单用户多任务型应用 
前面我们讨论的通常都是服务器端编程，其中一个假设就是用户数量很多。但如果面对
的是单用户，譬如本地的命令行工具或者图形界面，那么所谓的大量并发请求就不存在了。
于是另一个恐怖的问题出现了，尽管是单用户，却不一定是单任务。例如给用户提供界面的
同时后台在进行某个计算，为了让用户界面不出现阻塞状态，你不得不开启多线程或多进程。
而Node.js 线程或进程之间的通信到目前为止还很不便，因为它根本没有锁，因而号称不会
死锁。Node.js 的多进程往往是在执行同一任务，通过多进程利用多处理器的资源，但遇到
多进程相互协作时，就显得捉襟见肘了。 
3. 逻辑十分复杂的事务 
Node.js 的控制流不是线性的，它被一个个事件拆散，但人的思维却是线性的，当你试
图转换思维来迎合语言或编译器时，就不得不作出牺牲。举例来说，你要实现一个这样的逻
辑：从银行取钱，拿钱去购买某个虚拟商品，买完以后加入库存数据库，这中间的任何一步
都可能会涉及数十次的I/O 操作，而且任何一次操作失败以后都要进行回滚操作。这个过程
是线性的，已经很复杂了，如果要拆分为非线性的逻辑，那么其复杂程度很可能就达到无法
维护的地步了。 
Node.js更善于处理那些逻辑简单但访问频繁的任务，而不适合完成逻辑十分复杂的
工作。 
146  第 6 章  Node.js进阶话题 
 
4. Unicode 与国际化 
Node.js 不支持完整的Unicode，很多字符无法用 string 表示。公平地说这不是Node.js 的
缺陷，而是JavaScript  标准的问题。目前JavaScript  支持的字符集还是双字节的UCS2，即用
两个字节来表示一个Unicode 字符，这样能表示的字符数量是65536。显然，仅仅是汉字就不
止这个数目，很多生僻汉字，以及一些较为罕见语言的文字都无法表示。这其实是一个历史
遗留问题，像2000 年问题（俗称千年虫）一样，都起源于当时人们的主观判断。最早的Unicode 
设计者认为65536 个字符足以囊括全世界所有的文字了，因此那个时候盲目兼容Unicode 的系
统或平台（如Windows、Java 和JavaScript）在后来都遇到了问题。 
Unicode  随后意识到2 个字节是不够的，因此推出了UCS4，即用4  个字节来表示一个
Unicode 字符。很多原先用定长编码的UCS2  的系统都升级为了变长编码的UTF-16，因为只
有它向下兼容UCS2。UTF-16 对UCS2 以内的字符采用定长的双字节编码，而对它以外的部分
使用多字节的变长编码。这种方式的好处是在绝大多数情况下它都是定长的编码，有利于提
高运算效率，而且兼容了UCS2，但缺点是它本质还是变长编码，程序中处理多少有些不便。 
许多号称支持UTF-16 的平台仍然只支持它的子集UCS2，而不支持它的变长编码部分。
相比之下，UTF-8  完全是变长编码，有利于传输，而UTF-32 或UCS4 则是4  字节的定长编码，
有利于计算。 
当下的JavaScript  内部支持的仍是定长的UCS2  而不是变长的UTF-16，因此对于处理
UCS4  的字符它无能为力。所有的JavaScript  引擎都被迫保留了这个缺陷，包括V8 在内，因
此你无法使用Node.js 处理罕见的字符。想用Node.js 实现一个多语言的字典工具？还是算了
吧，除非你放弃使用string  数据类型，把所有的字符当作二进制的Buffer  数据来处理。 